# üß± SOLID Principles in Practice

---

Reposit√≥rio dedicado ao estudo, pr√°tica e documenta√ß√£o dos cinco princ√≠pios SOLID da programa√ß√£o orientada a objetos, com exemplos escritos em Java.

## üéØ Objetivo
Este projeto tem como foco:

- Compreender os conceitos por tr√°s de cada princ√≠pio SOLID;
- Implementar exemplos pr√°ticos e comentados em Python;
- Mostrar aplica√ß√µes corretas e incorretas (anti-patterns);
- Documentar aprendizados com README espec√≠ficos por princ√≠pio;
- Fortalecer fundamentos de arquitetura de software.

## üìö O que √© SOLID?
SOLID √© um acr√¥nimo para cinco princ√≠pios de design que ajudam a tornar sistemas orientados a objetos mais compreens√≠veis, flex√≠veis e f√°ceis de manter:

| Princ√≠pio | Nome                                       | Descri√ß√£o curta                                                            |
|-----------|--------------------------------------------|----------------------------------------------------------------------------|
| S         | Single Responsibility Principle (SRP)      | Uma classe deve ter apenas um motivo para mudar                            |
| O         | Open/Closed Principle (OCP)                | Entidades devem estar abertas para extens√£o, mas fechadas para modifica√ß√£o |
| L         | Liskov Substitution Principle (LSP)        | Subtipos devem ser substitu√≠veis por seus tipos base                       |
| I         | Interface Segregation Principle (ISP)      | Muitos contratos espec√≠ficos s√£o melhores que um contrato geral            |
| D         | Floor Dependency Inversion Principle (DIP) | Dependa de abstra√ß√µes, n√£o de implementa√ß√µes concretas                     |

## üí° Como usar
Cada subpasta cont√©m:

- ‚úÖ Um exemplo em Java aplicando o princ√≠pio;
- ‚ùå Um exemplo anti-pattern (opcional);
- üìù Um README.md explicando o conceito, a motiva√ß√£o e o exemplo.

## üöÄ Por que estudar SOLID?
Aprender e aplicar SOLID ajuda voc√™ a:
- Criar c√≥digo mais limpo, modular e reutiliz√°vel;
- Reduzir acoplamento e melhorar a manutenibilidade;
- Evoluir sua carreira como desenvolvedor backend, arquiteto ou engenheiro de software.